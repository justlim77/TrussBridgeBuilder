"""Tools to help in parsing a vizconnect config file."""

import collections
import copy
import os
import re

import vizconnect


CLASS_TO_PARSER_DICT = {
	'avatar':vizconnect.code.Avatar(),
	'display':vizconnect.code.Display(),
	'event':vizconnect.code.Event(),
	'input':vizconnect.code.Input(),
	'tool':vizconnect.code.Tool(),
	'tracker':vizconnect.code.Tracker(),
	'transport':vizconnect.code.Transport(),
}


def getParsedData(filename, classification):
	"""Return a set of parsed data given a filename and classification.
	@args '' ''
	@return {}
	"""
	try:
		parser = CLASS_TO_PARSER_DICT[classification]
	except KeyError:
		raise ValueError('**Error: Parser for classification {} not valid'.format(classification))
	
	# read the file with the parser and return the data
	fullCode = ''
	with open(filename, 'r') as tempFile:
		fullCode = tempFile.read()
	dataDict = {}
	codeDict = {}
	parser.parse(fullCode, dataDict, codeDict)
	
	return dataDict, parser


def getDataFromFile(filename):
	"""Returns all the data from a file
	
	@return {}
	"""
	fullCode = ''
	with open(filename, 'r') as tempFile:
		fullCode = tempFile.read()
	dataDict = collections.OrderedDict()# so it prints out in order tests are run
	codeDict = {}
	for parser in CLASS_TO_PARSER_DICT.values():
		parser.parse(fullCode, dataDict, codeDict)
	return dataDict


def getFullDataFromFile(filename):
	"""Returns all the data from a file
	
	@return {}
	"""
	fullCode = ''
	with open(filename, 'r') as tempFile:
		fullCode = tempFile.read()
	dataDict = collections.OrderedDict()# so it prints out in order tests are run
	codeDict = {}
	for parser in CLASS_TO_PARSER_DICT.values():
		parser.parse(fullCode, dataDict, codeDict)
	return dataDict, codeDict


def getParentConfigOffline(filename):
	"""Return the parent configuration filename of a given configuration.
	@args ''
	@return ''
	"""
	if not os.path.isfile(filename):
		return None
	
	parser = vizconnect.code.ParentConfiguration()
	fullCode = ''
	with open(filename, 'r') as tempFile:
		fullCode = tempFile.read()
	dataDict = {}
	codeDict = {}
	parser.parse(fullCode, dataDict, codeDict)
	param = vizconnect.getData(dataDict, ['parentConfiguration', 'parameters', 'parentConfiguration'])
	if param:
		return param['value']
	else:
		return None


def getFullConfigurationListOffline(filenameList):
	"""Given a list of configuration files, returns a full list including
	parent configurations.
	@args []
	@return []
	"""
	finalFileList = list(filenameList)
	for filename in filenameList:
		parentConfig = getParentConfigOffline(filename)
		while parentConfig:
			if not parentConfig in finalFileList:
				finalFileList.append(parentConfig)
				parentConfig = getParentConfigOffline(parentConfig)
			else:
				parentConfig = None
	return finalFileList


def getFullConfigurationList(filenameList):
	"""Given a list of configuration files, returns a full list including
	parent configurations.
	@args []
	@return []
	"""
	finalFileList = []
	for filename in filenameList:
		config = vizconnect.getConfiguration(filename)
		while config is not None:
			if not config.getFilename() in finalFileList:# add only new configurations
				finalFileList.append(config.getFilename())
				config = config.getParentConfiguration()
			else:
				config = None
	return finalFileList


def mergeClassification(classification, srcNodeDataDict, dstDataDict, dstCodeDict):
	"""Merges a classification """
	if dstDataDict is None or dstCodeDict is None:
		dstDataDict = collections.OrderedDict()
		dstCodeDict = {}
		blankCode = vizconnect.code.generateNew()
		CLASS_TO_PARSER_DICT[classification].parse(blankCode, dstDataDict, dstCodeDict)
	
	outputDataDict = copy.deepcopy(dstDataDict)
	outputCodeDict = copy.deepcopy(dstCodeDict)
	try:
		for nodeName in srcNodeDataDict:
			vizconnect.setData(outputDataDict, srcNodeDataDict[nodeName], accessList=[classification, 'node', nodeName])
			nodeCode = CLASS_TO_PARSER_DICT[classification].generateNode(nodeName, srcNodeDataDict[nodeName])
			vizconnect.setData(outputCodeDict, nodeCode, accessList=[classification, 'node', nodeName, '*code'])
			vizconnect.setData(outputCodeDict, [0, 0], accessList=[classification, nodeName, '*chars'])
	except KeyError:
		outputDataDict = copy.deepcopy(dstDataDict)
		outputCodeDict = copy.deepcopy(dstCodeDict)
	return outputDataDict, outputCodeDict


def saveAllCode(filename, dataDict, codeDict):
	"""Saves all code from the data dict"""
	finalCode = vizconnect.code.generateNew()
	for classification, parser in CLASS_TO_PARSER_DICT.iteritems():
		if classification in dataDict:
			finalCode = parser.generate(finalCode, dataDict, codeDict, None)
	with open(filename, 'w') as tempFile:
		tempFile.write(finalCode)


def parseMetaDataBlock(text):
	"""Returns a dictionary with keys for each set of data obtained
	from the configuration.
	
	@return {}
	"""
	data = {}
	if not 'This module was generated by Vizconnect.' in text:
		return data
	
	for key, expression, defaultValue in [('generated', 'Generated on: (.*)', None),
											('version', 'Version: (.*)', None),
											('preset', 'Preset: (.*)', None),
											('addons', 'Addons: (\[.*\])', [])]:
		match = re.search(expression, text)
		if match:
			data[key] = match.group(1)
		else:
			data[key] = defaultValue
	
	if data['addons']:
		data['addons'] = eval(data['addons'])
	return data


def generateMetaDataText(data):
	"""Returns text generated from the meta data data.
	
	@return ""
	"""
	return '\
"""\n\
This module was generated by Vizconnect.\n\
Version: {}\n\
Generated on: {}\n\
Preset: {}\n\
Addons: {}\n\
"""'.format(data['version'],
			data['generated'],
			data['preset'],
			data['addons'])


def getMetaDataBlockFromText(text):
	"""Provides functionality for parsing the meta data from the text of a
	vizconnect configuration file. Returns a string
	
	@return ""
	"""
	match = re.search('.*?(\"\"\".*?\"\"\")', text, flags=re.DOTALL)
	if match:
		return match.group(1)
	else:
		return ""


def getMetaDataBlockFromConfiguration(configuration=None):
	"""Provides functionality for parsing the meta data from a vizconnect
	configuration. Returns a string.
	
	@return ""
	"""
	if configuration is None:
		configuration = vizconnect.getConfiguration()
	return configuration.getModule().__doc__


def updateMetaData(fullText, newData):
	"""Updates existing metadata by updating the existing meta data dict and 
	returning the resulting file text
	
	@return ""
	"""
	originalMetaDataText = getMetaDataBlockFromText(fullText)
	data = parseMetaDataBlock(originalMetaDataText)
	data.update(newData)
	newDataText = generateMetaDataText(data)
	return fullText.replace(originalMetaDataText, newDataText)


if __name__ == '__main__':
	mode = 2
	
	def applyPreset():
		"""Tests applying preset"""
		import preset_database
		print preset_database.PRESETS['VizMove_Walking_VR']['hardware']['tracker']
		srcDataDict = getDataFromFile('vizconnect_config.py')
		print srcDataDict['tracker']['node']
		outputDataDict, outputCodeDict = mergeClassification('tracker',
																preset_database.PRESETS['VizMove_Walking_VR']['hardware']['tracker'],
																dstDataDict=None,
																dstCodeDict=None)
		saveAllCode('vizconnect_output_test.py', outputDataDict, outputCodeDict)
	
	def capturePreset():
		"""Tests capturing preset"""
		srcDataDict = getDataFromFile('sample_config.py')
		classification = 'input'
		outputDataDict, outputCodeDict = mergeClassification(classification,
																srcNodeDataDict=srcDataDict[classification]['node'],
																dstDataDict=None,
																dstCodeDict=None)
		saveAllCode('vizconnect_output_test.py', outputDataDict, outputCodeDict)
		
		def parameterReprReplacement(self):
			"""replaces vizconnect.code._Parameter print statement, so we can save it out properly."""
			return "vizconnect.code._Parameter(**{})".format(super(vizconnect.code._Parameter, self).__repr__())
		vizconnect.code._Parameter.__repr__ = parameterReprReplacement
		
		def mappingReprReplacement(self):
			"""replaces vizconnect.code._Mapping print statement, so we can save it out properly."""
			return "vizconnect.code._Mapping(**{})".format(super(vizconnect.code._Mapping, self).__repr__())
		vizconnect.code._Mapping.__repr__ = mappingReprReplacement
		
		with open('dict.py', 'w') as tempFile:
			tempFile.write(outputDataDict[classification]['node'].__repr__())
	
	def testGetMetaDataFromLoadedConfig():
		"""Tests getting meta data from a config already loaded as a module"""
		vizconnect.go('base_vizconnect_config.py')
		print getMetaDataBlockFromConfiguration()
	
	def testUpdateMetaData():
		"""Tests udating meta data for a config"""
		with open('sample_config.py', 'r') as tempFile:
			fullText = tempFile.read()
			print updateMetaData(fullText, {'addons':['test_output']})
	
	if mode == 0:
		applyPreset()
	elif mode == 1:
		capturePreset()
	elif mode == 2:
		testUpdateMetaData()


def getToolMapping(slotName, toolName=None, filename=None):
	"""Add mappings from the given filename"""
	classification = 'tool'
	if filename is None:
		filename = vizconnect.getConfiguration().getFilename()
	dataDict, parser = getParsedData(filename, classification)
	# want to sample if event is live, so change context
	tempFilename = vizconnect.getConfiguration().getFilename()
	vizconnect.ConfigurationManager.setCurrent(filename)
	
	if toolName is None:
		toolName = vizconnect.getTool().getName()
	toolWrapper = vizconnect.getTool(toolName)
	
	mappingText = None
	for mappingTuple in parser.iterNodeMappings(dataDict):
		name, data = mappingTuple[0:2]
		
		if name == toolName:
			for mapping in data['list']:
				for signal in mapping['signalList']:
					if mapping['slotName'] == slotName:
						mappingText = signal['signalName'].lower()
						if signal['negativeSignal']:
							mappingText = "not "+mappingText
	vizconnect.ConfigurationManager.setCurrent(tempFilename)
	return mappingText

